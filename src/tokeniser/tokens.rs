use super::{
    brackets::Bracket, keywords::Keyword, literals::Literal, operators::Operator, symbols::Symbol,
};

#[derive(Debug, PartialEq)]
pub enum Token {
    Keyword(Keyword),
    Operator(Operator),
    Bracket(Bracket),
    Literal(Literal),
    Symbol(Symbol),
}

impl TryFrom<&str> for Token {
    type Error = ();

    fn try_from(value: &str) -> Result<Self, ()> {
        match value {
            "import" => Ok(Self::Keyword(Keyword::Import)),
            "struct" => Ok(Self::Keyword(Keyword::Struct)),
            "return" => Ok(Self::Keyword(Keyword::Return)),
            "i8" => Ok(Self::Keyword(Keyword::SignedInteger8)),
            "i16" => Ok(Self::Keyword(Keyword::SignedInteger16)),
            "i32" => Ok(Self::Keyword(Keyword::SignedInteger32)),
            "i64" => Ok(Self::Keyword(Keyword::SignedInteger64)),
            "u8" => Ok(Self::Keyword(Keyword::UnsignedInteger8)),
            "u16" => Ok(Self::Keyword(Keyword::UnsignedInteger16)),
            "u32" => Ok(Self::Keyword(Keyword::UnsignedInteger32)),
            "u64" => Ok(Self::Keyword(Keyword::UnsignedInteger64)),
            "f32" => Ok(Self::Keyword(Keyword::Float32)),
            "f64" => Ok(Self::Keyword(Keyword::Float64)),
            "char" => Ok(Self::Keyword(Keyword::Character)),
            "bool" => Ok(Self::Keyword(Keyword::Boolean)),
            "const" => Ok(Self::Keyword(Keyword::Constant)),
            "if" => Ok(Self::Keyword(Keyword::If)),
            "else" => Ok(Self::Keyword(Keyword::Else)),
            "while" => Ok(Self::Keyword(Keyword::While)),
            "for" => Ok(Self::Keyword(Keyword::For)),
            "in" => Ok(Self::Keyword(Keyword::In)),
            "break" => Ok(Self::Keyword(Keyword::Break)),
            "continue" => Ok(Self::Keyword(Keyword::Continue)),
            "true" => Ok(Self::Keyword(Keyword::True)),
            "false" => Ok(Self::Keyword(Keyword::False)),
            "=" => Ok(Self::Operator(Operator::Assign)),
            "+" => Ok(Self::Operator(Operator::Add)),
            "+=" => Ok(Self::Operator(Operator::AddAssign)),
            "-" => Ok(Self::Operator(Operator::Subtract)),
            "-=" => Ok(Self::Operator(Operator::SubAssign)),
            "*" => Ok(Self::Operator(Operator::Multiply)),
            "*=" => Ok(Self::Operator(Operator::MulAssign)),
            "/" => Ok(Self::Operator(Operator::Divide)),
            "/=" => Ok(Self::Operator(Operator::DivAssign)),
            "%" => Ok(Self::Operator(Operator::Modulus)),
            "%=" => Ok(Self::Operator(Operator::ModAssign)),
            "&" => Ok(Self::Operator(Operator::BitAnd)),
            "&=" => Ok(Self::Operator(Operator::BitAndAssign)),
            "|" => Ok(Self::Operator(Operator::BitOr)),
            "|=" => Ok(Self::Operator(Operator::BitOrAssign)),
            "&&" => Ok(Self::Operator(Operator::And)),
            "||" => Ok(Self::Operator(Operator::Or)),
            "!" => Ok(Self::Operator(Operator::Not)),
            "==" => Ok(Self::Operator(Operator::Equal)),
            "!=" => Ok(Self::Operator(Operator::NotEqual)),
            "<" => Ok(Self::Operator(Operator::LessThan)),
            ">" => Ok(Self::Operator(Operator::GreaterThan)),
            "<=" => Ok(Self::Operator(Operator::LessThanEqual)),
            ">=" => Ok(Self::Operator(Operator::GreaterThanEqual)),
            "(" => Ok(Self::Bracket(Bracket::RoundOpen)),
            ")" => Ok(Self::Bracket(Bracket::RoundClose)),
            "[" => Ok(Self::Bracket(Bracket::SquareOpen)),
            "]" => Ok(Self::Bracket(Bracket::SquareClose)),
            "{" => Ok(Self::Bracket(Bracket::CurlyOpen)),
            "}" => Ok(Self::Bracket(Bracket::CurlyClose)),
            ";" => Ok(Self::Symbol(Symbol::End)),
            "," => Ok(Self::Symbol(Symbol::Seperator)),
            "." => Ok(Self::Symbol(Symbol::Get)),
            other => Ok(Self::Literal(Literal::try_from(other)?)),
        }
    }
}
